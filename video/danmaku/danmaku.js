(() =>
{
    return (settings, resources) =>
    {
        class Danmaku
        {
            constructor(content, time, type, fontSize, color)
            {
                this.content = content;
                this.time = time;
                this.type = type;
                this.fontSize = fontSize;
                this.color = color;
            }
        }
        class XmlDanmaku extends Danmaku
        {
            constructor({ content, time, type, fontSize, color, timeStamp, pool, userHash, rowId })
            {
                super(content, time, type, fontSize, color);
                this.timeStamp = timeStamp;
                this.pool = pool;
                this.userHash = userHash;
                this.rowId = rowId;
                this.pDataArray = [time, type, fontSize, color, timeStamp, pool, userHash, rowId];
            }
            text()
            {
                const pData = this.pDataArray.join(",");
                return `<d p="${pData}">${this.content}</d>`;
            }
            static parse(element)
            {
                const pData = element.getAttribute("p");
                [time, type, fontSize, color, timeStamp, pool, userHash, rowId] = pData.split(",");
                const content = element.innerText;
                return new XmlDanmaku({ content, time, type, fontSize, color, timeStamp, pool, userHash, rowId });
            }
        }
        class XmlDanmakuDocument
        {
            constructor(xml)
            {
                this.xml = xml;
                const document = new DOMParser().parseFromString(xml, "application/xml").documentElement;
                this.danmakus = [...document.querySelectorAll("d[p]")].map(it => new XmlDanmaku(it));
            }
        }
        class AssDanmaku extends Danmaku
        {
            constructor({ content, time, type, fontSize, color, typeTag, colorTag, endTime })
            {
                super(content, time, type, fontSize, color);
                this.typeTag = typeTag;
                this.colorTag = colorTag;
                this.endTime = endTime;
            }
            text(fontStyles)
            {
                const styleName = fontStyles[this.fontSize].match(/Style:(.*?),/)[1].trim();
                return `Dialogue: 0,${this.time},${this.endTime},${styleName},,0,0,0,,{${this.typeTag}${this.colorTag}}${this.content}`;
            }
        }
        class AssDanmakuDocument
        {
            constructor({ danmakus, title, fontStyles, blockTypes, resolution })
            {
                this.danmakus = danmakus;
                this.title = title;
                this.fontStyles = fontStyles;
                this.blockTypes = blockTypes;
                this.resolution = resolution;
            }
            generateAss()
            {
                const meta = `
[Script Info]
; Script generated by Bilibili Evolved Danmaku Converter
; https://github.com/the1812/Bilibili-Evolved/
Title: ${this.title}
ScriptType: v4.00+
PlayResX: ${this.resolution.x}
PlayResY: ${this.resolution.y}
Timer: 10.0000
WrapStyle: 2
ScaledBorderAndShadow: no

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
${Object.values(this.fontStyles).join("\n")}

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
                `.trim();
                return meta + "\n" + this.danmakus
                    .map(it => it.text(this.fontStyles, this.blockTypes))
                    .filter(it => it !== "").join("\n");
            }
        }

        class DanmakuStack
        {
            constructor(font, resolution)
            {
                this.horizontal = [];
                this.vertical = [];
                this.canvas = document.createElement("canvas");
                this.context = canvas.getContext("2d");
                // XML字体大小到实际大小的表
                this.fontSizes = {
                    25: `36pt ${font}`,
                    18: `26pt ${font}`,
                };
                this.danmakuType = {
                    1: "normal",
                    2: "normal",
                    3: "normal",
                    4: "bottom",
                    5: "top",
                    6: "reversed",
                    7: "special",
                    8: "special",
                };
            }
            getHorizonalTags(danmaku)
            {

            }
            getVerticalTags(danmaku)
            {

            }
            push(danmaku)
            {
                let tags = null;
                let stack = null;
                switch (this.danmakuType[danmaku.type])
                {
                    case "normal":
                    case "reversed":
                        {
                            tags = this.gegetHorizonalTagstTags(danmaku);
                            stack = this.horizontal;
                            break;
                        }
                    case "top":
                    case "bottom":
                        {
                            tags = this.getVerticalTags(danmaku);
                            stack = this.vertical;
                            break;
                        }
                    case "special":
                    default:
                        {
                            throw new Error("Danmaku type not supported");
                        }
                }
                const info = {
                    tags
                };
                stack.push(info);
                return info;
            }
        }
        class DanmakuConverter
        {
            constructor({ title, font, alpha, duration, blockTypes, resolution })
            {
                this.title = title;
                this.font = font;
                this.alpha = Math.round(alpha * 100);
                this.duration = duration;
                this.blockTypes = blockTypes;
                this.resolution = resolution;
                this.danmakuStack = new DanmakuStack(font, resolution);
            }
            get fontStyles()
            {
                return {
                    25: `Medium,${this.font},36,&H${this.alpha}FFFFFF,&H${this.alpha}FFFFFF,&H${this.alpha}000000,&H${this.alpha}000000,0,0,0,0,100,100,0,0,1,1,0,5,0,0,0,0`,
                    18: `Small,${this.font},26,&H${this.alpha}FFFFFF,&H${this.alpha}FFFFFF,&H${this.alpha}000000,&H${this.alpha}000000,0,0,0,0,100,100,0,0,1,1,0,5,0,0,0,0`,
                };
            }
            convertToAssDocument(xmlDanmakuDocument)
            {
                const assDanmakus = [];
                for (const xmlDanmaku of xmlDanmakuDocument.danmakus)
                {
                    // 跳过高级弹幕和设置为屏蔽的弹幕类型
                    if (this.blockTypes.concat(7, 8).indexOf(xmlDanmaku.type) !== -1)
                    {
                        continue;
                    }
                    const [startTime, endTime] = this.convertTime(xmlDanmaku.time, this.duration);
                    assDanmakus.push(new AssDanmaku({
                        content: xmlDanmaku.content,
                        time: startTime,
                        endTime: endTime,
                        type: xmlDanmaku.type,
                        fontSize: xmlDanmaku.fontSize,
                        color: xmlDanmaku.color,
                        typeTag: this.convertType(xmlDanmaku),
                        colorTag: this.convertColor(xmlDanmaku.color),
                    }));
                }
                return new AssDanmakuDocument({
                    danmakus: assDanmakus,
                    title: this.title,
                    blockTypes: this.blockTypes,
                    fontStyles: this.fontStyles,
                    resolution: this.resolution
                });
            }
            convertType(danmaku)
            {
                return this.danmakuStack.push(danmaku).tags;
            }
            convertColor(decColor)
            {
                const white = 16777215;
                if (decColor === white)
                {
                    return "";
                }
                const hex = decColor.toString(16);
                const red = hex.substring(4, 6);
                const green = hex.substring(2, 4);
                const blue = hex.substring(0, 2);
                return `\\c&H${blue}${green}${red}&`;
            }
            convertTime(startTime, duration)
            {
                function round(number)
                {
                    return Math.round(number * 100) / 100;
                }
                function secondsToTime(seconds)
                {
                    let hours = 0;
                    let minutes = 0;
                    while (seconds >= 60)
                    {
                        seconds -= 60;
                        minutes++;
                    }
                    while (minutes >= 60)
                    {
                        minutes -= 60;
                        hours++;
                    }
                    return `${hours}:${minutes.toString().padStart(2, "0")}:${round(seconds).toString().padStart(4, "0")}`;
                }
                return [secondsToTime(startTime), secondsToTime(startTime + duration)];
            }
        }
        return {
            export: {
                AssDanmaku,
                AssDanmakuDocument,
                Danmaku,
                DanmakuConverter,
                DanmakuStack,
                XmlDanmaku,
                XmlDanmakuDocument,
            },
        };
    };
})();