(() =>
{
    return (settings, resources) =>
    {
        class Danmaku
        {
            constructor(content, time, type, fontSize, color)
            {
                this.content = content;
                this.time = time;
                this.type = type;
                this.fontSize = fontSize;
                this.color = color;
            }
        }
        class XmlDanmaku extends Danmaku
        {
            constructor({ content, time, type, fontSize, color, timeStamp, pool, userHash, rowId })
            {
                super(content, time, type, fontSize, color);
                this.timeStamp = timeStamp;
                this.pool = pool;
                this.userHash = userHash;
                this.rowId = rowId;
                this.pDataArray = [time, type, fontSize, color, timeStamp, pool, userHash, rowId];
            }
            text()
            {
                const pData = this.pDataArray.join(",");
                return `<d p="${pData}">${this.content}</d>`;
            }
            static parse(element)
            {
                const pData = element.getAttribute("p");
                [time, type, fontSize, color, timeStamp, pool, userHash, rowId] = pData.split(",");
                const content = element.innerText;
                return new XmlDanmaku({ content, time, type, fontSize, color, timeStamp, pool, userHash, rowId });
            }
        }
        class XmlDanmakuDocument
        {
            constructor(xml)
            {
                this.xml = xml;
                const document = new DOMParser().parseFromString(xml, "application/xml").documentElement;
                this.danmakus = [...document.querySelectorAll("d[p]")].map(it => new XmlDanmaku(it));
            }
        }
        class AssDanmaku extends Danmaku
        {
            constructor({ content, time, type, fontSize, color, typeTag, endTime })
            {
                super(content, time, type, fontSize, color);
                this.typeTag = typeTag;
                this.endTime = endTime;
            }
            text(fontStyles)
            {
                if (this.type === 7 || this.type === 8)
                {
                    return "";
                }
                const style = fontStyles[this.fontSize].match(/Dialogue.*?,.*?,.*?,(.*?),/)[1].trim();
                return `Dialogue: 0,${this.time},${this.endTime},${style},,0,0,0,,{${this.typeTag}\\c&H${this.color}&}${this.content}`;
            }
        }
        class AssDanmakuDocument
        {
            constructor(danmakus)
            {
                this.danmakus = danmakus;
            }
            generateAss({ title, fontStyles })
            {
                const meta = `
[Script Info]
; Script generated by Bilibili Evolved Danmaku Converter
; https://github.com/the1812/Bilibili-Evolved/
Title: ${title}
ScriptType: v4.00+
PlayResX: 1920
PlayResY: 1080
Timer: 10.0000
WrapStyle: 2
ScaledBorderAndShadow: no

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
${Object.values(fontStyles).join("\n")}

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
                `.trim();
                return meta + "\n" + danmakus.map(it => it.text(fontStyles)).filter(it => it !== "").join("\n");
            }
        }
    };
})();