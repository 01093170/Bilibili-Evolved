"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const danmaku_1 = require("./danmaku");
class AssDanmaku extends danmaku_1.Danmaku {
    constructor({ content, time, type, fontSize, color, typeTag, colorTag, endTime }) {
        super({ content, time, type, fontSize, color });
        this.typeTag = typeTag;
        this.colorTag = colorTag;
        this.endTime = endTime;
    }
    text(fontStyles) {
        const styleName = fontStyles[this.fontSize].match(/Style:(.*?),/)[1].trim();
        return `Dialogue: 0,${this.time},${this.endTime},${styleName},,0,0,0,,{${this.typeTag}${this.colorTag}}${this.content}`;
    }
}
exports.AssDanmaku = AssDanmaku;
class AssDanmakuDocument {
    constructor(danmakus, title, fontStyles, blockTypes, resolution) {
        this.danmakus = danmakus;
        this.title = title;
        this.fontStyles = fontStyles;
        this.blockTypes = blockTypes;
        this.resolution = resolution;
    }
    generateAss() {
        const meta = `
[Script Info]
; Script generated by Bilibili Evolved Danmaku Converter
; https://github.com/the1812/Bilibili-Evolved/
Title: ${this.title}
ScriptType: v4.00+
PlayResX: ${this.resolution.x}
PlayResY: ${this.resolution.y}
Timer: 10.0000
WrapStyle: 2
ScaledBorderAndShadow: no

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
${Object.values(this.fontStyles).join('\n')}

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
                `.trim();
        return meta + '\n' + this.danmakus
            .map(it => it.text(this.fontStyles))
            .filter(it => it !== '').join('\n');
    }
}
exports.AssDanmakuDocument = AssDanmakuDocument;
